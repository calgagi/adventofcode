/*
 * generated by github.com/calgagi/cp_gen
 * file: A.cpp
 * time: Sun Dec  6 21:02:19 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_map<string, vector<string>> graph;
unordered_map<string, bool> visited;
unordered_map<string, bool> good;
int ans = 0;

void parse_rule(const string& rule) {
    int contain = rule.find("contain");
    if (contain == string::npos) {
        cout << "INVALID" << endl;
    }
    string from = rule.substr(0, contain-1);
    if (from.back() != 's') {
        from.push_back('s');
    }
    string to = "";
    for (int i = contain + string("contain ").length(); i < rule.length(); i++) {
        if (rule[i] == ',' || rule[i] == '.') {
            graph[from].push_back(to);
            to = "";
        }
        else {
            to += rule[i];
        }
    }

    /* cout << from << ":"; */
    for (string& s : graph[from]) {
        for (int i = 0; i < s.length() && ((s[i] <= '9' && s[i] >= '0') || s[i] == ' '); i++) {
            s.erase(s.begin());
        }
        for (int i = s.length()-1; i >= 0 && s[i] != 'g'; i--) {
            s.pop_back();
        }
        s.push_back('s');
        s.erase(s.begin());
        /* cout << s << ","; */
    }
    /* cout << endl; */

    return;
}

bool dfs(string cur) {
    cout << cur << endl;
    if (visited[cur]) {
        cout << "HERE: " << cur << endl;
        return good[cur];
    }
    visited[cur] = true;
    for (string& to : graph[cur]) {
        /* cout << to << " "; */
        bool x = dfs(to);
        if (x) {
            good[cur] = true;
            break;
        }
        /* cout << "POP" << endl; */
    }
    return good[cur];
}


void solve() {
    vector<string> in;
    string line;
    while (getline(cin, line)) {
        in.push_back(line);
    }

    for (string& line : in) {
        parse_rule(line);
    }

    visited["shiny gold bags"] = true;
    good["shiny gold bags"] = true;
    for (pair<string, vector<string>> node : graph) {
        if (!visited[node.first]) {
            good[node.first] = dfs(node.first);
        }
    }

    int ans = 0;
    for (pair<string, bool> cur : good) {
        ans += cur.second;
    }
    cout << ans << endl;

    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
