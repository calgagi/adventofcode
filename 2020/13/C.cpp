/*
 * generated by github.com/calgagi/cp_gen
 * file: C.cpp
 * time: Sun Dec 13 16:20:53 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

const ll MOD = 1e9 + 7;

ll gcd(ll a, ll b) {
    assert(a != 0 && b != 0);
    while (b) {
        a %= b;
        swap(a, b);
    }
    return a;
}

ll lcm(ll a, ll b) {
    return (a * b) / gcd(a, b);
}

ll modpow(ll base, ll exp, ll mod = MOD) {
    ll ans = 1;
    base %= mod;
    while (exp) {
        if (exp & 1LL) {
            ans = (ans * base) % mod;
        }
        exp >>= 1;
        base = (base * base) % mod;
    }
    return ans;
}

ll crt(const vector<ll>& n, const vector<ll>& a) {
    assert(n.size() == a.size());
    ll x = 0;
    ll N = 1;
    int s = n.size();
    for (int i = 0; i < s; i++) {
        assert(a[i] < n[i]);
        N *= n[i];
        for (int j = i+1; j < s; j++) {
            assert(gcd(n[i], n[j]) == 1);
        }
    }
    for (int i = 0; i < s; i++) {
        ll b = N / n[i];
        x = (x + ((((b * a[i]) % N) * modpow(b, n[i]-2, n[i])) % N)) % N;
    }
    return x;
}

void solve() {
    string s;
    getline(cin, s);
    getline(cin, s);

    vector<ll> nums, rem;
    for (int i = 0, j = 0; i < (int) s.length(); i++, j++) {
        string num = "";
        while (i < (int) s.length() && s[i] != ',')
            num += s[i++];
        if (num != "x") {
            nums.push_back(stoll(num));
            // we want X such that:
            // (X + rem[i]) % nums[i] == 0
            // that is:
            // X % nums[i] == -rem[i]
            // where -rem[i] is the additive inverse of rem[i]. therefore:
            // X % nums[i] == nums[i] - rem[i]
            ll r = stoll(num) - j;
            r %= stoll(num);
            if (r < 0) {
                r += stoll(num);
            }
            cout << r << endl;
            rem.push_back(r);
        }
    }

    cout << crt(nums, rem) << endl;

    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
