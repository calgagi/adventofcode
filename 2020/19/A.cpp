/*
 * generated by github.com/calgagi/cp_gen
 * file: A.cpp
 * time: Fri Dec 18 21:02:10 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

vector<string> received;
vector<string> rules;
string msg;

// i = rule idx, j = left, k = right
// -1 = uneval, 0 = no match, 1 = match
vector<vector<vector<int>>> dp;
int num_rules;

struct Node {
    vector<vector<int>> reps;
    char match = ' ';
};

vector<Node> idxToNode(200);

// we know parsing is doing correctly from diff
void parse_rule(string& s) {
    int colon = s.find(":");
    int idx = stoi(s.substr(0, colon));

    Node& node = idxToNode[idx];
    
    int i = colon+2;
    if (s[i] == '\"') {
        node.match = s[i+1];
        cout << idx << ": \"" << s[i+1] << "\"" << endl;
    }
    else {
        vector<int> idxs;
        string num = "";
        for (; i < (int) s.length(); i++) {
            if (s[i] == '|') {
                node.reps.push_back(idxs);
                idxs.clear();
                // get rid of space
                i++;
            }
            else if (s[i] == ' ') {
                idxs.push_back(stoi(num)); 
                num = "";
            }
            else {
                num += s[i];
            }
        }
        if (num != "") {
            idxs.push_back(stoi(num));
        }
        if (!idxs.empty()) {
            node.reps.push_back(idxs);
        }

        cout << idx << ": ";
        for (i = 0; i < (int) node.reps.size(); i++) {
            for (int j = 0; j < (int) node.reps[i].size(); j++) {
                cout << node.reps[i][j];
                if (j != node.reps[i].size() - 1) {
                    cout << " ";
                }
            }
            if (i != node.reps.size() - 1) {
                cout << " | ";
            }
        }
        cout << endl;
    }

    assert((node.match != ' ' + node.reps.size() != 0) == 1);
    return;
}

int go(int rule, int left, int right);

int divy(int i, const vector<int>& rep, int left, int right) {
    // if we're completely out of rules and space, we have found the right configuration
    if (i >= rep.size() && left > right) {
        return 1;
    }
    // if we have run out of rules or run out spaces but not both, we haven't used
    // all of the rules or space. return false
    if (i >= rep.size() || left > right) {
        return 0;
    }

    for (int j = left; j <= right; j++) {
        if (go(rep[i], left, j) == 1 && divy(i+1, rep, j+1, right) == 1) {
            return 1;
        }
    }
    return 0;
}

int go(int rule, int left, int right) {
    // get the node for the rule
    Node& node = idxToNode[rule];

    // we need to check if left == right and if it matches the message's character
    if (left >= right || node.match != ' ') {
        dp[rule][left][right] = (left == right && node.match == msg[left] ? 1 : 0);
        return dp[rule][left][right];
    }

    // caching
    if (dp[rule][left][right] != -1) {
        return dp[rule][left][right];
    }

    // set this to false
    dp[rule][left][right] = 0;
    for (vector<int>& rep : node.reps) {
        // if we can divy up the rule's representation in msg[left -> right]
        if (1 == divy(0, rep, left, right)) {
            dp[rule][left][right] = 1;
            break;
        }
    }

    return dp[rule][left][right];
}

int complete(string s) {
    msg = s;
    int n = msg.length();
    dp.clear();
    dp.assign(num_rules, vector<vector<int>>(n, vector<int>(n, -1)));
    return go(0, 0, n-1);
}

void solve() {
    bool mode = false;
    string line;
    while (getline(cin, line)) {
        if (line == "") {
            mode = true;
        }
        if (!mode) rules.push_back(line);
        else if (line != "") received.push_back(line);
    }
    
    num_rules = rules.size();
    for (string& s : rules) {
        parse_rule(s);
    }

    ll ans = 0;
    for (string& s : received) {
        if (1 == complete(s)) {
            ans++;
            cout << s << endl;
        }
    }
    cout << ans << "/" << received.size() << endl;
    
    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
