/*
 * generated by github.com/calgagi/cp_gen
 * file: A.cpp
 * time: Fri Dec 18 21:02:10 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

vector<string> received;
vector<string> rules;

// i = rule idx, j = left, k = right
// -1 = uneval, 0 = no match, 1 = match
int num_rules;

struct Node {
    vector<vector<int>> reps;
    char match = ' ';
};

vector<Node> rule_to_node(200);
vector<unordered_set<string>> dp(200);

// we know parsing is doing correctly from diff
void parse_rule(string& s) {
    int colon = s.find(":");
    int idx = stoi(s.substr(0, colon));

    Node& node = rule_to_node[idx];
    
    int i = colon+2;
    if (s[i] == '\"') {
        node.match = s[i+1];
    }
    else {
        vector<int> idxs;
        string num = "";
        for (; i < (int) s.length(); i++) {
            if (s[i] == '|') {
                node.reps.push_back(idxs);
                idxs.clear();
                // get rid of space
                i++;
            }
            else if (s[i] == ' ') {
                idxs.push_back(stoi(num)); 
                num = "";
            }
            else {
                num += s[i];
            }
        }
        if (num != "") {
            idxs.push_back(stoi(num));
        }
        if (!idxs.empty()) {
            node.reps.push_back(idxs);
        }
    }

    assert((node.match != ' ' + node.reps.size() != 0) == 1);
    return;
}

void add_to_end(unordered_set<string>& a, const unordered_set<string>& b) {
    if (a.size() == 0) {
        a = b;
        return;
    }
    unordered_set<string> ans;
    for (const string& x : a) {
        for (const string& y : b) {
            ans.insert(x + y);
        }
    }
    a = ans;
}

void perform_union(unordered_set<string>& a, const unordered_set<string>& b) {
    for (const string& x : b) {
        a.insert(x);
    }
    return;
}

int counter_mx = 3;

unordered_set<string> generate(int rule, int from, int counter) {
    if (counter == 0 || dp[rule].size() != 0) {
        return dp[rule];
    }

    Node& node = rule_to_node[rule];
    if (node.match != ' ') {
        dp[rule].insert(string(1, node.match));
    }
   
    for (vector<int>& rep : node.reps) {
        unordered_set<string> cur;
        for (int& x : rep) {
            add_to_end(cur, generate(x, rule, (rule == x ? counter - 1 : counter_mx)));
        }
        perform_union(dp[rule], cur);
    }
    cout << rule << " " << dp[rule].size() << endl;

    return dp[rule];
}

void solve() {
    bool mode = false;
    string line;
    while (getline(cin, line)) {
        if (line == "") {
            mode = true;
        }
        if (!mode) rules.push_back(line);
        else if (line != "") received.push_back(line);
    }
    
    num_rules = rules.size();
    for (string& s : rules) {
        parse_rule(s);
    }

    unordered_set<string> generated = generate(0, 0, counter_mx);
    for (const string& x : dp[8]) cout << x << endl;
    for (const string& x : dp[11]) cout << x << endl;

    ll ans = 0;
    for (string& s : received) {
        if (generated.count(s)) {
            ans++;
        }
    }
    cout << ans << endl;
    
    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
