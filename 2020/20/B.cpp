/*
 * generated by github.com/calgagi/cp_gen
 * file: A.cpp
 * time: Sat Dec 19 20:59:38 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

map<int, vector<string>> tile;
vector<int> ids;

// i = id, j = orientation, k = {0, 1, 2} where:
//      0 = ID, 1 = orientation, 2 = direction
map<int, vector<vector<array<int,3>>>> match;

const int side = 12;
const int w = 10;

vector<vector<array<int,2>>> board(side, vector<array<int,2>>(side, {-1, -1}));
map<int, bool> used;

// only need below + right connections
// we start at top left
// go right all the way, down, repeat

vector<string> rotate(const vector<string>& a) {
    vector<string> ans = a;
    int l = a.size();
    for (int j = 0; j < l/2; j++) {
        for (int i = j; i < l-1-j; i++) {
            ans[j][i] = a[i][l-1-j];
            ans[i][l-1-j] = a[l-1-j][w-1-i];
            ans[l-1-j][l-1-i] = a[l-1-i][j];
            ans[l-1-i][j] = a[j][i];
        }
    }
    return ans;
}

vector<string> mirror(const vector<string>& a) {
    vector<string> ans = a;
    int l = a.size();
    for (int j = 0; j < l; j++) {
        for (int i = 0; i < l/2; i++) {
            swap(ans[j][i], ans[j][l-i-1]);
        }
    }
    return ans;
}

// direction = 0 => a's right match with b's left
// direction = 1 => a's up match with b's down
bool matches(const vector<string>& a, const vector<string>& b, bool direction) {
    for (int i = 0; i < w; i++) {
        if (!direction) {
            if (a[i][w-1] != b[i][0]) {
                return false;
            }
        }
        else {
            if (a[0][i] != b[w-1][i]) {
                return false;
            }
        }
    }
    return true;
}

void print_tile(const vector<string>& x) {
    for (const string& a : x) {
        cout << a << endl;
    }
    cout << endl;
}

void print_board() {
    for (int i = 0; i < side; i++) {
        for (int j = 0; j < side; j++) { 
            cout << board[i][j][0] << "\t";
        }
        cout << endl;
    }
    cout << endl;
    return;
}

bool backtrack(int row, int col, int tile, int ori) {
    if (used[tile]) {
        return false;
    }

    // check if this tile with this orientation (ori) can fit according to the above tile if it exists
    if (row-1 >= 0) {
        int id_above = board[row-1][col][0], ori_above = board[row-1][col][1];
        bool ok = false;
        for (const array<int,3>& m : match[id_above][ori_above]) {
            if (m[2] == 1 && m[0] == tile && m[1] == ori) {
                ok = true;
                break;
            }
        }
        if (!ok) {
            return false;
        }

    }

    // place tile, then backtrack
    used[tile] = true;
    board[row][col] = {tile, ori};

    if (row == side-1 && col == side-1) return true;
    
    // row+1
    if (col == side-1) {
        for (const array<int,3>& m : match[board[row][0][0]][board[row][0][1]]) {
            if (m[2] == 1 && backtrack(row+1, 0, m[0], m[1])) {
                return true;
            }
        }
    }
    else {
        for (const array<int,3>& m : match[tile][ori]) {
            if (m[2] == 0 && backtrack(row, col+1, m[0], m[1])) {
                return true; 
            }
        }
    }

    // remove tile and backtrack
    used[tile] = false;
    board[row][col] = {-1, -1};
    return false;
}

void solve() {
    vector<string> in;
    string line;
    while (getline(cin,line)) {
        in.push_back(line);
    }

    for (int i = 0; i < (int) in.size(); i++) {
        string num = in[i].substr(in[i].find(" ") + 1);
        num.pop_back();
        int id = stoi(num);
        i++;
        for (int j = 0; j < w; j++, i++) {
            tile[id].push_back(in[i]);
        }
        ids.push_back(id);
        match[id].resize(8);
    }

    // preprocess matches
    for (int i = 0; i < (int) ids.size(); i++) {
        for (int j = 0; j < (int) ids.size(); j++) {
            if (i == j) {
                continue;
            }
            int id1 = ids[i], id2 = ids[j];
            vector<string> tile1 = tile[id1];
            for (int orientation1 = 0; orientation1 < 8; orientation1++) {
                if (orientation1 == 4) {
                    tile1 = mirror(tile1);
                }
                vector<string> tile2 = tile[id2];
                for (int orientation2 = 0; orientation2 < 8; orientation2++) {
                    if (orientation2 == 4) {
                        tile2 = mirror(tile2);
                    }
                    for (int ori = 0; ori < 2; ori++) {
                        if (matches(tile1, tile2, ori)) {
                            match[id1][orientation1].push_back({id2, orientation2, ori});
                        }
                    }
                    tile2 = rotate(tile2);
                }
                tile1 = rotate(tile1);
            }
        }
    }
    
    for (int& id : ids) {
        for (int ori = 0; ori < 8; ori++) {
            if (backtrack(0, 0, id, ori)) {
                goto FOUND;
            }
        }
    }

FOUND:
    // part 1
    cout << (ll) board[0][0][0] * board[side-1][0][0] * board[side-1][side-1][0] * board[0][side-1][0] << endl;

    /* for (int i = 0; i < side; i++) { */
    /*     for (int j = 0; j < side; j++) { */
    /*         vector<string> gen_tile(ids */


    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
