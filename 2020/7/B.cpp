/*
 * generated by github.com/calgagi/cp_gen
 * file: A.cpp
 * time: Sun Dec  6 21:02:19 2020
 */

#include<bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef long double ld;

unordered_map<string, vector<string>> graph;
unordered_map<string, vector<int>> counts;
unordered_map<string, bool> visited;
unordered_map<string, bool> good;
int ans = 0;

void parse_rule(const string& rule) {
    int contain = rule.find("contain");
    if (contain == string::npos) {
        cout << "INVALID" << endl;
    }
    string from = rule.substr(0, contain-1);
    if (from.back() != 's') {
        from.push_back('s');
    }
    string to = "";
    for (int i = contain + string("contain ").length(); i < rule.length(); i++) {
        if (rule[i] == ',' || rule[i] == '.') {
            string num = "";
            for (int j = 0; j < to.length() && to[j] <= '9' && to[j] >= '0'; j++) {
                num += to[j];
                to.erase(to.begin());
            }
            counts[from].push_back((num == "" ? 0 : stoi(num)));
            graph[from].push_back(to);
            to = "";
            i++;
        }
        else {
            to += rule[i];
        }
    }

    for (string& s : graph[from]) {
        for (int i = s.length()-1; i >= 0 && s[i] != 'g'; i--) {
            s.pop_back();
        }
        s.push_back('s');
        s.erase(s.begin());
    }

    return;
}

long long dfs(string cur) {
    // 1 bag at least
    long long ans = 1;
    for (int i = 0; i < graph[cur].size(); i++) {
        /* cout << to << " "; */
        ans += dfs(graph[cur][i]) * counts[cur][i];
        /* cout << "POP" << endl; */
    }
    return ans;
}


void solve() {
    vector<string> in;
    string line;
    while (getline(cin, line)) {
        in.push_back(line);
    }

    for (string& line : in) {
        parse_rule(line);
    }

    long long ans = dfs("shiny gold bags");
    cout << ans << endl;

    return;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    srand(chrono::steady_clock::now().time_since_epoch().count());

    int num_tests = 1;
    /* cin >> num_tests; */
    for (int i = 0; i < num_tests; i++) {
        solve();
    }

    return 0;
}
